import numpy as np
import pandas as pd
import random

from mesa import Model, Agent
from mesa.time import RandomActivation
from mesa.space import SingleGrid
from mesa.datacollection import DataCollector

import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import matplotlib.colors as colors

VERBOSE = 1

class SchellingModel(Model):
    '''
    Model class for the Schelling segregation model.
    '''
    def __init__(self, side =10, density=0.7, minority_pc=0.3, tolerance_treshold =0.3):
        '''
        side: side of the grid square
        density: density of population
        minority_pc: percentage of minority type (2 types in ths case) =>  minority: 0 = all blue, 1 = all red
        tolerance_treshold: percentage of neighbours requested of same type
        '''

        self.side = side
        self.density = density
        self.minority_pc = minority_pc
        self.tolerance_treshold = tolerance_treshold
        self.girdSize = side*side
        
        #A scheduler which activates each agent once per step, in random order, with the order reshuffled every step
        self.schedule = RandomActivation(self)

        #Grid where each cell contains exactly at most one object. default rectangular
        self.grid = SingleGrid(width=side, height=side, torus=False)

        #Reset total happy agents counting
        self.total_happy = 0

        #Standard way to collect data generated by a Mesa model. 
        #It collects three types of data: model-level data, agent-level data, and tables

        self.datacollector = DataCollector(
            {"perc_happy": lambda m: m.total_happy/m.schedule.get_agent_count(),
             "tot_seg": lambda m: np.mean([a.segregation for a in self.schedule.agents])},
            {"x": lambda a: a.pos[0], 
             "y": lambda a: a.pos[1],
             "segregation": lambda a: a.segregation})

        #Boolean attributes indicating if the model should continue running
        self.running = True

        agent_id=0

        # Set up agents
        # We use a grid iterator that returns
        # the coordinates of a cell as well as
        # its contents. (coord_iter)
        for cell in self.grid.coord_iter():
            x = cell[1]
            y = cell[2]

            if random.random() < self.density:              #if true, selected cell is populated, else is empty
                if random.random() < self.minority_pc:      #if true, cell is populated with minority, else with majority type
                    agent_type = 1
                else:
                    agent_type = 2

                agent = SchellingAgent(agent_id, (x, y), self, agent_type)      #instance of agent class
                agent_id += 1
                self.grid.place_agent(agent, (x, y))    #Positions an agent on the grid, and set its pos variable.                        
                self.schedule.add(agent)                   #Add an Agent object to the schedule.

        self.num_free_cells = self.girdSize - self.schedule.get_agent_count() #num blank cells



    def step(self):
        '''
        Run one step of the model. If All agents are happy, halt the model.
        '''
        self.total_happy = 0                                        #Reset counter of happy agents
        self.schedule.step()                                        #Call agents steps
        self.datacollector.collect(self)                            #Collect all the data for the given model object    
        if self.total_happy == self.schedule.get_agent_count():     #Halt condition
            self.running = False
        #self.show()


    def show(self):
        agent_counts = np.zeros((self.grid.width, self.grid.height))
        for cell in self.grid.coord_iter():
            cell_content, x, y = cell
            if cell_content != None: 
                agent_counts[x][y] = cell_content.type

        cmap = colors.ListedColormap(['white', '#ff3300','#0033ff'])
        plt.imshow(agent_counts, interpolation="nearest", cmap=cmap)
        ax = plt.gca()
        major_ticks = np.arange(-0.5,self.side-0.5,1)
        ax.set_xticks(major_ticks)
        ax.set_yticks(major_ticks)
        ax.grid(True)
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        plt.show()
        


class SchellingAgent(Agent):
    '''
    Schelling segregation agent
    '''
    def __init__(self, unique_id, pos, model, agent_type):
        '''
        unique_id: id identifying agents
        pos: tuple of (x,y) coordinates
        model: model of agent
        agent_type: could be 1 or 2
        '''
        super().__init__(unique_id, model) 
        self.pos = pos
        self.type = agent_type
        self.tot_neighbors=8
        self.freeCellsRank = None #dataframe used by each agent to relocate
        
    def find_new_location(self):

        self.freeCellsRank = pd.DataFrame(0, index=np.arange(self.model.num_free_cells), columns=['x','y','happiness'])
        if(VERBOSE):
            print("STAMPA RANK")
            print(self.freeCellsRank)
        i = 0
        
        print(f"Agent in pos {self.pos}, di tipo {self.type}")


        #for each cell in the whole grid
        for cell in self.model.grid.coord_iter():
            
            cell_content, x, y = cell
            
            #if it is free
            if(self.model.grid.is_cell_empty((x,y))):
                if(VERBOSE):
                    print(f"Sono in {x,y}")

                #record coords in the freeCellsRank df
                self.freeCellsRank.iat[i,0] = x
                self.freeCellsRank.iat[i,1] = y
                
                #compute the happiness that the agent would have in that cell
                num_neighbors = len(self.model.grid.get_neighbors((x,y), moore = True))
                if(VERBOSE): 
                    print(f"Num neigh contando anche me: {num_neighbors}")

                neighbors = self.model.grid.iter_neighbors((x,y), "moore")      
                similar = 0
                for neighbor in neighbors:
                    if(neighbor.pos == self.pos):
                        num_neighbors -=1
                        pass
                    else:
                        print(f"Neigh è {neighbor.pos}")
                        if neighbor.type == self.type:
                            similar += 1
                if(VERBOSE):             
                    print(f"Num neigh senza contare anche me: {num_neighbors}")
                    print(f"Similar sono {similar}")

                #compute the happiness the agent would have in that blank cell
                happiness = float(similar/self.tot_neighbors)
                if(VERBOSE): 
                    print(f"Happiness è {happiness}")

                #associate the happiness to that blank cell
                self.freeCellsRank.iat[i,2] = happiness
                
                i+=1

        #print("FUORI DAL FOR")        
        self.freeCellsRank.sort_values(by="happiness", inplace = True, ascending = False)
        self.freeCellsRank.reset_index(inplace = True, drop=True)
        if(VERBOSE):
            print(f"freeCellsRank è {self.freeCellsRank}")
        self.segregation = self.freeCellsRank.iloc[0]["happiness"]
        return (int(self.freeCellsRank.iloc[0]["x"]), int(self.freeCellsRank.iloc[0]["y"]))
               
               
             
    def step(self):
        similar = 0                                                         #Reset similar counting
        neighbors = self.model.grid.iter_neighbors(self.pos, "moore")       #Return an iterator over neighbors to a certain point
        for neighbor in neighbors:
            if neighbor.type == self.type:
                similar += 1

        self.segregation = similar/self.tot_neighbors

        if self.segregation < self.model.tolerance_treshold:
            #self.model.grid.move_to_empty(self)
            new_loc_x, new_loc_y = self.find_new_location()
            if(VERBOSE): 
                print(f"got new location at {new_loc_x, new_loc_y}")
            self.model.grid.move_agent(self, (new_loc_x, new_loc_y))

            ###
            #self.model.grid.move_to_empty(self)
            ##
        else:
            self.model.total_happy += 1