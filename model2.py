import numpy as np
import pandas as pd
import random

from mesa import Model, Agent
from mesa.time import RandomActivation
from mesa.space import SingleGrid
from mesa.datacollection import DataCollector

import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import matplotlib.colors as colors



class SchellingModel(Model):
    '''
    Model class for the Schelling segregation model.
    '''
    def __init__(self, side =10, density=0.7, minority_pc=0.3, homophily =0.3, relocation_policy="pure_random", neighborhood_type = 'abs', verbose = 0):
        '''
        side: side of the grid square
        density: density of population
        minority_pc: percentage of minority type (2 types in ths case) =>  minority: 0 = all blue, 1 = all red
        homophily: percentage of neighbours requested of same type
        '''

        if(relocation_policy  in ["pure_random","mild_random","min_gain","max_gain"]):
            self.relocation_policy = relocation_policy 
        else:
            raise Exception("Error on the given policy name") 

        self.neighborhood_type = neighborhood_type
        self.verbose = verbose
        self.side = side
        self.density = density
        self.minority_pc = minority_pc
        self.homophily = homophily
        self.girdSize = side*side
        
        #A scheduler which activates each agent once per step, in random order, with the order reshuffled every step
        self.schedule = RandomActivation(self)

        #Grid where each cell contains exactly at most one object. default rectangular
        self.grid = SingleGrid(width=side, height=side, torus=False)

        #Reset total happy agents counting
        self.total_happy = 0

        #Standard way to collect data generated by a Mesa model. 
        #It collects three types of data: model-level data, agent-level data, and tables

        self.datacollector = DataCollector(
            {"perc_happy": lambda m: m.total_happy/m.schedule.get_agent_count(),
             "tot_seg": lambda m: np.mean([a.segregation for a in self.schedule.agents])},
            {"x": lambda a: a.pos[0], 
             "y": lambda a: a.pos[1],
             "segregation": lambda a: a.segregation})

        #Boolean attributes indicating if the model should continue running
        self.running = True

        agent_id=0

        # Set up agents
        # We use a grid iterator that returns
        # the coordinates of a cell as well as
        # its contents. (coord_iter)
        for cell in self.grid.coord_iter():
            x = cell[1]
            y = cell[2]

            if random.random() < self.density:              #if true, selected cell is populated, else is empty
                if random.random() < self.minority_pc:      #if true, cell is populated with minority, else with majority type
                    agent_type = 1
                else:
                    agent_type = 2

                agent = SchellingAgent(agent_id, (x, y), self, agent_type)      #instance of agent class
                agent_id += 1
                self.grid.place_agent(agent, (x, y))    #Positions an agent on the grid, and set its pos variable.                        
                self.schedule.add(agent)                   #Add an Agent object to the schedule.

        self.num_free_cells = self.girdSize - self.schedule.get_agent_count() #num blank cells



    def step(self):
        '''
        Run one step of the model. If All agents are happy, halt the model.
        '''
        self.total_happy = 0                                        #Reset counter of happy agents
        self.schedule.step()                                        #Call agents steps
        self.datacollector.collect(self)                            #Collect all the data for the given model object    
        if self.total_happy == self.schedule.get_agent_count():     #Halt condition
            self.running = False
        #self.show()


    def show(self):
        agent_counts = np.zeros((self.grid.width, self.grid.height))
        for cell in self.grid.coord_iter():
            cell_content, x, y = cell
            if cell_content != None: 
                agent_counts[x][y] = cell_content.type

        cmap = colors.ListedColormap(['white', '#ff3300','#0033ff'])
        plt.imshow(agent_counts, interpolation="nearest", cmap=cmap)
        ax = plt.gca()
        major_ticks = np.arange(-0.5,self.side-0.5,1)
        ax.set_xticks(major_ticks)
        ax.set_yticks(major_ticks)
        ax.grid(True)
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        plt.show()
        


class SchellingAgent(Agent):
    '''
    Schelling segregation agent
    '''
    def __init__(self, unique_id, pos, model, agent_type):
        '''
        unique_id: id identifying agents
        pos: tuple of (x,y) coordinates
        model: model of agent
        agent_type: could be 1 or 2
        '''
        super().__init__(unique_id, model) 
        self.pos = pos
        self.type = agent_type
        self.tot_neighbors=8
        self.freeCellsRank = None #dataframe used by each agent to relocate
        
    def find_new_location(self):

        self.freeCellsRank = pd.DataFrame(0, index=np.arange(self.model.num_free_cells), columns=['x','y','happiness'])
        if(self.model.verbose):
            print("STAMPA RANK")
            print(self.freeCellsRank)
        i = 0

        if(self.model.verbose):
            print(f"Agent in pos {self.pos}, di tipo {self.type}")


        #for each cell in the whole grid
        for cell in self.model.grid.coord_iter():
            
            cell_content, x, y = cell
            
            #if it is free
            if(self.model.grid.is_cell_empty((x,y))):
                if(self.model.verbose):
                    print(f"Sono in {x,y}")

                #record coords in the freeCellsRank df
                self.freeCellsRank.iat[i,0] = x
                self.freeCellsRank.iat[i,1] = y
                
                #compute the happiness that the agent would have in that cell
                num_neighbors = len(self.model.grid.get_neighbors((x,y), moore = True))
                if(self.model.verbose): 
                    print(f"Num neigh contando anche me: {num_neighbors}")

                neighbors = self.model.grid.iter_neighbors((x,y), "moore")      
                similar = 0
                for neighbor in neighbors:
                    if(neighbor.pos == self.pos):
                        num_neighbors -=1
                        pass
                    else:
                        if(self.model.verbose):
                            print(f"Neigh è {neighbor.pos}")
                        if neighbor.type == self.type:
                            similar += 1
                            
                if(self.model.verbose):             
                    print(f"Num neigh senza contare anche me: {num_neighbors}")
                    print(f"Similar sono {similar}")

                #compute the happiness the agent would have in that blank cell
                if(self.model.neighborhood_type=="abs"):
                    happiness = similar/self.tot_neighbors
                else:
                    if(num_neighbors > 0):
                        happiness = similar/num_neighbors
                    else:
                        happiness = 0

                if(self.model.verbose): 
                    print(f"Happiness è {happiness}")

                #associate the happiness to that blank cell
                self.freeCellsRank.iat[i,2] = happiness
                
                i+=1

        #now for each blank cell has been computed its happiness        
        self.freeCellsRank.sort_values(by="happiness", inplace = True, ascending = False)
        self.freeCellsRank.reset_index(inplace = True, drop=True)
        if(self.model.verbose):
            print(f"freeCellsRank è {self.freeCellsRank}")

        self.segregation = self.freeCellsRank.iloc[0]["happiness"]
        
        #choose the new location according to the chosen policy
        #["pure_random","mild_random","min_gain","max_gain"]:
        df_happy = self.freeCellsRank[self.freeCellsRank["happiness"]>=self.model.homophily]
        df_happy.reset_index(inplace=True,  drop=True)
        
        if(self.model.verbose):
            print(f"df_happy è {df_happy}")
        
        if(df_happy.empty):
            raise Exception("ERROR: No location available with the given homophily")

        if(self.model.relocation_policy == "mild_random"):
            index = random.randint(0, len(df_happy)-1)     
            ret_x = int(df_happy.iloc[index]["x"])
            ret_y = int(df_happy.iloc[index]["y"])

        if(self.model.relocation_policy == "min_gain"):     
            ret_x = int(df_happy.iloc[-1]["x"])
            ret_y = int(df_happy.iloc[-1]["y"])

        if(self.model.relocation_policy == "max_gain"):
            ret_x = int(df_happy.iloc[0]["x"])
            ret_y = int(df_happy.iloc[0]["y"])
        return ret_x, ret_y
               
               
             
    def step(self):
        similar = 0      
                                                           #Reset similar counting
        neighbors = self.model.grid.iter_neighbors(self.pos, "moore")       #Return an iterator over neighbors to a certain point

        num_neighbors = len(self.model.grid.get_neighbors(self.pos, moore = True))
        print("LEN NEIHG")
        print(num_neighbors)
        for neighbor in neighbors:
            if neighbor.type == self.type:
                similar += 1

        if(self.model.neighborhood_type=="abs"):
            self.segregation = similar/self.tot_neighbors
        else:
            if(num_neighbors>0):
                self.segregation = similar/num_neighbors
            else:
                self.segregation = 0

        if self.segregation < self.model.homophily:
            if(self.model.relocation_policy == "pure_random"):
                self.model.grid.move_to_empty(self)
            else:
                new_loc_x, new_loc_y = self.find_new_location()
                if(self.model.verbose): 
                    print(f"got new location at {new_loc_x, new_loc_y}")
                self.model.grid.move_agent(self, (new_loc_x, new_loc_y))
        else:
            self.model.total_happy += 1